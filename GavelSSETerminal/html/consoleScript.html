<div id="status">Startup...</div>
<div id="terminal"></div>
<input type="text" id="input" placeholder="Enter a command ('?' or 'help')..." autofocus />

<script>
document.addEventListener('DOMContentLoaded', () => {
    console.log('✅ Script loaded and DOM ready');

    const terminal = document.getElementById('terminal');
    const input = document.getElementById('input');
    const status = document.getElementById('status');

    let eventSource;
    let lastHeartbeat = Date.now();
    const heartbeatTimeout = 30000; // 30s
    const sseURL = `${window.location.origin}/sse_events`;

    // Command history tracking
    let commandHistory = [];
    let historyIndex = -1;

    // ✅ Update status text and color
    function updateStatus(text, color = 'lightgray') {
        status.textContent = text;
        status.style.color = color;
    }

    // ✅ ANSI Parsing Function
    function parseANSI(text) {
        const span = document.createElement('span');
        const regex = /\x1b\[([\d;]*)([A-Za-z])/g;
        let lastIndex = 0;
        let match;
        let currentColor = '';

        while ((match = regex.exec(text)) !== null) {
            const chunk = text.slice(lastIndex, match.index);
            if (chunk) {
                const part = document.createElement('span');
                if (currentColor) part.style.color = currentColor;
                part.textContent = chunk;
                span.appendChild(part);
            }

            const params = match[1].split(';').map(Number);
            const command = match[2];
             if (command === 'm') {
                params.forEach(code => {
                    switch (code) {
                        case 30: currentColor = 'black'; break;
                        case 31: currentColor = 'red'; break;
                        case 32: currentColor = 'limegreen'; break;
                        case 33: currentColor = 'yellow'; break;
                        case 34: currentColor = 'blue'; break;
                        case 35: currentColor = 'magenta'; break;
                        case 36: currentColor = 'cyan'; break;
                        case 37: currentColor = 'white'; break;
                        case 0: currentColor = ''; break;
                    }
                });
            } else if (command === 'J') {
                // Clear screen
                if (params[0] === 2 || params.length === 0) {
                    terminal.innerHTML = ''; // Clear terminal content
                }
            } else if (command === 'H') {
                // Move cursor to home (optional)
                terminal.scrollTop = 0;
            }

            lastIndex = regex.lastIndex;
        }

        const remaining = text.slice(lastIndex);
        if (remaining) {
            const part = document.createElement('span');
            if (currentColor) part.style.color = currentColor;
            part.textContent = remaining;
            span.appendChild(part);
        }

        return span;
    }

    // ✅ Append message to terminal
    function appendMessage(text, cssClass = '') {
        const message = document.createElement('div');
        if (cssClass) message.className = cssClass;

        message.appendChild(parseANSI(text)); // Parse ANSI colors
        terminal.appendChild(message);

        // Limit terminal to 500 messages
        while (terminal.children.length > 500) {
            terminal.removeChild(terminal.firstChild);
        }
        terminal.scrollTop = terminal.scrollHeight;
    }

    // ✅ Connect to SSE
    function connectSSE() {
        updateStatus('Connecting...', 'orange');
        console.log('Connecting to SSE:', sseURL);
        eventSource = new EventSource(sseURL);

        eventSource.onopen = () => updateStatus('Connected', 'limegreen');
        eventSource.onmessage = (event) => appendMessage(event.data);
        eventSource.addEventListener('heartbeat', () => {
            lastHeartbeat = Date.now();
            console.log('Heartbeat received');
        });

        eventSource.onerror = () => {
            updateStatus('Connection lost. Retrying...', 'orange');
            appendMessage('[Warning] Connection lost. Retrying...', 'warning');
            eventSource.close();
            setTimeout(connectSSE, 2000);
        };
    }

    // ✅ Heartbeat watchdog
    setInterval(() => {
        if (Date.now() - lastHeartbeat > heartbeatTimeout) {
            updateStatus('No heartbeat. Reconnecting...', 'red');
            appendMessage('[Warning] No heartbeat detected. Reconnecting...', 'warning');
            try { eventSource && eventSource.close(); } catch (_) {}
            connectSSE();
        }
    }, 10000);

    // ✅ Command input handler
    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const command = input.value.trim();
            if (!command) return;

            // Save command to history
            commandHistory.push(command);
            historyIndex = commandHistory.length;

            fetch(`${window.location.origin}/sse_command`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command })
            })
            .then(response => {
                if (!response.ok) appendMessage(`[Error] Server responded with ${response.status}`, 'error');
            })
            .catch(error => appendMessage(`[Error] ${error.message}`, 'error'));

            input.value = '';
        } else if (e.key === 'ArrowUp') {
            if (historyIndex > 0) {
                historyIndex--;
                input.value = commandHistory[historyIndex];
            }
            e.preventDefault();
        } else if (e.key === 'ArrowDown') {
            if (historyIndex < commandHistory.length - 1) {
                historyIndex++;
                input.value = commandHistory[historyIndex];
            } else {
                historyIndex = commandHistory.length;
                input.value = '';
            }
            e.preventDefault();
        }
    });
    
    connectSSE();
});
</script>
